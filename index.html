
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>QUIRKI â€” Language Summary</title>

    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css"
    />

    <style>
      :root {
        color-scheme: dark;
        --bg: #0b0f14;
        --panel: rgba(255, 255, 255, 0.04);
        --panel-border: rgba(255, 255, 255, 0.08);
        --text: rgba(255, 255, 255, 0.88);
        --muted: rgba(255, 255, 255, 0.63);
        --accent: #7c3aed;
      }
      body {
        line-height: 150%;
        margin: 3px;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica,
          Arial;
        background: radial-gradient(1200px 700px at 30% -10%, #1b2a44 0%, transparent 55%),
          radial-gradient(900px 600px at 90% 0%, #2b1747 0%, transparent 50%),
          var(--bg);
        color: var(--muted);
      }
      .wrap {
        max-width: 980px;
        margin: 0 auto;
        padding: 40px 18px 56px;
      }
      header {
        margin-bottom: 28px;
        color: var(--text);
      }
      h1 {
        margin: 0 0 8px;
        font-size: clamp(30px, 4vw, 42px);
        letter-spacing: -0.02em;
        color: var(--text);
        
      }
      .subtitle {
        color: var(--muted);
        font-size: 15px;
      }
      .card {
        background: var(--panel);
        border: 1px solid var(--panel-border);
        border-radius: 16px;
        overflow: hidden;
        box-shadow: 0 14px 40px rgba(0, 0, 0, 0.35);
        margin-bottom: 18px;
      }
      .toolbar {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 12px 16px;
        border-bottom: 1px solid var(--panel-border);
        background: rgba(0, 0, 0, 0.25);
      }
      .dot {
        width: 8px;
        height: 8px;
        border-radius: 999px;
        background: var(--accent);
        box-shadow: 0 0 0 3px rgba(124, 58, 237, 0.15);
      }
      .section-title {
        font-size: 14px;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        color: rgba(255, 255, 255, 0.75);
      }
      .content {
        padding: 0px;
        margin-top: 0px;
      }
      h2 {
        margin: 0 0 8px;
        font-size: 20px;
        color: var(--text);
      }
      p {
        margin: 0 0 10px;
        color: var(--muted);
      }
      ul {
        margin: 0 0 0px px;
      }
      li {
        margin-bottom: 6px;
      }
      pre {
        margin: 0;
      }
      pre[class*="language-"] {
        background: transparent !important;
        line-height: 100%;
      }
      code[class*="language-"] {
        font-size: 14px;
        
      }
    </style>
  </head>

  <body>
    <div class="wrap">
      <h1>QUIRKI</h1>
      An experimental programming language. </br>
      It is fast, memory-safe and data-oriented. </br>
      It's very opinionated,
      and very quirki. </br>
    <br />
    <br />

    <h2>
    Functions and ownership
    </h2>
    
    Unlike most languages, Quirki does not allow functions to return values. </br>
    Instead, functions mutate data. Ownership becomes clear. </br>
    And it's dead simple to reason about code.
    </br></br>
    
    <pre class="card"><code class="language-quirki">
// Instead of using keywords, Quirki uses positional syntax.
// Mutating parameters come first, followed by function 
// and readonly parameters.

new hero // Data is zero initialized on creation.

hero TakeDamage(i_amount)
hero Move(f3_dir)
      
// Can also be written with pipeline syntax:
hero
| TakeDamage(i_amount)
| Move(f3_dir)

// You can also take ownership with keyword: take
hero GrabItem(take item)

// And have multiple mutable parameters:
enemy, ammo Shoot(weapon)
</code></pre>
  
</br>
</br>


<h2>
VARIABLES & NAMES
</h2>
The language is strongly typed, but types are never explicitly declared. </br>
Quirki infers types from variable names using type names as prefixes. </br>
You are encouraged to use the type name as the variable name. </br>
</br>
Here's how <i><b>other</b></i> similar languages defines a function:</br>
<pre class="card"><code class="language-quirki">
fn PushDamage(hero: mut &Hero, transform:&Transform, weapon:Weapon, amount: Int)

</code></pre>
</br></br>

Now lets look at Quirki's version.</br>
<pre class="card"><code class="language-quirki">
fn hero PushDamage(weapon, transform, i_amount)

</code></pre>
</br>
</br>

It's obvious when you are mixing types.
<pre class="card"><code class="language-quirki">i_health -= f_damage 
</code></pre>

</br>
</br>
</br>
</br>


<h2>
Enums
</h2>
Enums are used heavily in Quirki.
<pre class="card"><code class="language-quirki">Enum FireWeapon: // simple enum
    success
    no_ammo
    jammed


Enum AIState: // enum with data
    Idle
    Patrol(f3_dir)
    Attack(entity)
    Flee(f3_dir, f_speed)


Enum LoadedAsset: // error handling
    Success(asset) 
    ! NotFound // <- Enums may declare failure variants.
    ! PermissionDenied // <- More on this failure later.

// ( Enums with failure variants must have
// a single payload type for all successes.
// This makes nice unwrapping possible. )


</code></pre>
</br></br>
<h2>
  Branching & Pattern Matching
</h2>

There's only one control-flow method: "<b> ? </b>"  </br>
So there's no: IF or SWITCH, TRY etc. </br> </br>

" ? " simply pattern-matches on data. </br>
It is exhaustive by default. </br>

<pre class="card"><code class="language-quirki">
? hero.ai_state
| Idle: hero Rest()
| Patrol(dir): hero Move(dir)
| else: pass // use else to catch-all
    
// Unwrapping optional works the same way:
? hero.enemy_target?
| some(enemy): hero Shoot(enemy)
| none: hero Search()

// You can introduces a temporary value to match on using: #
? # GetTotalAmmo(hero)
| # > 0: hero Shoot()
| else: hero Reload()

// Error handling with enums
? LoadTexture(path)
| Success(asset):   loadedAssets(take asset)
| NotFound:         Log("Texture not found")
| PermissionDenied: Log("Permission denied")

// If our enum has failure variants, as shown before,
// Using ! unwraps success and propagates failure automatically.
! texture LoadTexture(path)

// And since optionals are just enums with a failure variant. They work the same.
! enemy hero.enemy_target?

// Boolean is an enum with some syntax sugar.
// so you dont have to write out "| true:"

? has_ammo CheckAmmo(hero)
    hero Shoot()
| else:
    hero Reload()


          </code></pre>

      </section>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

    <script>
Prism.languages.quirki = {
  comment: { pattern: /\/\/[^\n]*/, greedy: true },

  string: { pattern: /"(?:\\.|[^"\\\r\n])*"/, greedy: true },

  keyword: /\b(?:Struct|Enum|else|take|new)\b/,

  // NOTE: removed builtin rule so i_health won't highlight

  // Types / Enum / Struct names (PascalCase)
  "class-name": /\b[A-Z][A-Za-z0-9_]*\b/,

  // Functions: Foo(...) and obj.Foo
  function: [
    /\b[A-Za-z_][A-Za-z0-9_]*(?=\s*\()/,
    /(?<=\.)[A-Za-z_][A-Za-z0-9_]*/,
  ],

  number: /\b\d+(?:\.\d+)?\b/,

  variable: /#[A-Za-z_][A-Za-z0-9_]*/,

  operator: /[?|:#]/,

  punctuation: /[()|.,]/,
};

Prism.highlightAll();
</script>
  </body>
</html>
